<!doctype html>
<html lang="en" data-framework="jquery">
<head>
  <meta charset="utf-8">
<style>
body {font-family:Helvetica,Arial,sans-serif;font-size:1.0rem; margin: 10px 10px 10px 20px; line-height:1.5;}
h1 {font-size:1.5rem; color:#27A;}
h2 {font-size:1.25rem;}
p.hangl-li {margin-left:8px;}
pre {margin: 2px 4px 2px 8px; border:solid thin blue; padding:4px 4px 4px 8px; overflow:auto; line-height:1.2}
</style>
</head>
<body>
<h1>Getting Started</h1>
<p>Tags lets you implement custom tags in Javascript. This makes 
   it easy to bind tags to event handlers, create and manipulate dynamic 
   HTML and implement widgets with a clean HTML interface.</p>
<p>This document describes the Tags Framework at a conceptual level and describes
   how to use the features of the framework. See the 
   <a href='http://randomsoftwareideas.com/tags-framework/jsdocs/index.html'>API</a> document
   for programming details.</p>
<h2>Handling Objects</h2>
<p>To begin with, Tags provides a Class mechanism to define object types and instantiate objects. 
   Internally, it is based on <a href='http://ejohn.org/blog/simple-javascript-inheritance/'>Class.js</a>, 
   but Tags provides an interface based on the define() and create() methods:

<ul>
  <li>Tags.define - Define a new class for instantiating objects</li>
  <p class='hang-li'>This takes an object whose 'tag' attribute indicates
     the name of the class being defined. An 'extend' tag, if present, indicates the
     class being extended. Any additional attributes or methods provided are
     added to the prototype of the Class being defined.</p>

  <li>Tags.create - Instantiate and initialize an object</li>
  <p class='hang-li'>This can take a variety of input types including XML
     and Javascript object. The input specifies the class to be instantiated and
     any attributes to be initialized. It also may include nested XML or Javascript
     objects.</p>
  <p>You can use the Tags.create() method to create a Tag object from
     an XML-Node object, a string that contains XML text or a Javascript
     object that mimics the functionality of XML. In practice, this means
     you can create a Tag object from XML contained inside of an HTML &lt;script&gt;
     tag or you can build up the object using Javascript. When we get to the
     View class, you will see that the former is most
     useful for generating static HTML and the later is typically used for
     generating dynamic HTML.</p> 
</ul>  

<h2>Handling Views</h2>
<p>The Tags Framework defines a built-in Class called View. The key methods of the View class 
   are its render() and activate() methods.</p>
<ul>  
  <li>view.render - Render the object as XML (or HTML)</li>
  
  <p class='hang-li'>This calls view.renderText() 
      internally to render a string representation of the HTML and converts it to
      a jQuery DOM element.</li>
  
  <li>view.activate - Attach event handlers and do other DOM related activities</li>
  
  <p class='hang-li'>The View object provides a useful context in which to
      define event handlers.</p>
</ul>       

<p>What makes the View class useful is that any unrecognized tag name is bound to the View Class
   and this lets you create View structures that represent HTML and can be used
   to render and manipulate HTML DOM objects.</p> 

<p>Using a View object requires a sequence of operations that includes instantiate,
   render, attach to the DOM and activate. Here is how that would work for
   a simple "Hello World" case using jQuery.</p>
   
<pre>
var view = Tags.create({tag:'div', content:'Hello World'});  // Instantiate
$(document).append(view.render());  // Render and attach to the DOM
view.activate(); // Activate
</pre>

<p>As you can see, this gives one a lot of flexibility in creating View 
   components for rendering dynamic HTML.</p>

<h2>Custom Tags</h2>

<p>The next step is to define your own custom tags. Simply define your render() and activate() 
   methods as needed and you can place your custom tag anywhere a normal HTML tag would go. 
   In practice, we override the renderText() method rather than the render() method. Here 
   is a Hello World example ...</p>
   
<pre>
Tags.define({  
  tag:'hello',
  extend:'view',
  renderText:function() {
    if (this.message) this.content = this.message;
    return this.renderAs('span');
  }
});
</pre>
<pre>
...
&lt;body&gt;
  &lt;script type='text/custom-tags'&gt;
    &lt;hello message='Hello World'/&gt;
    &lt;hello&gt;Hello Again&lt;/hello&gt;
  &lt;/script&gt;
&lt;/body&gt;
...
</pre>

<p>The instantiate, render, attach and activate sequence is done automatically
   by the Tags Framework in the case of HTML contained within &lt;script&gt; tags
   with a type of 'text/custom-tags'. The rendered HTML tag will be inserted into
   the DOM at a position just after the &lt;script&gt; tag. This feature lets you
   use custom tags just as you use standard HTML tags.</p>
   
<p>If you do not want this automatic behavior, just give the &lt;script&gt; some
   other type than 'text/custom-tag'.</p>

<p>One nice thing about the Tags Framework is that custom tags are light-weight 
   and easy to define. This means you can create a custom tag just to bind an event 
   handler. Say you had an &lt;input&gt; tag to Start an operation and you wanted 
   to bind it to an event handler.  You could do this easily with jQuery, but there 
   is nothing in the &lt;input&gt; tag itself to tell you this is going to happen. 
   And you have to create an ID for the &lt;input&gt;. And where are you going to put 
   that jQuery code? And you have to make sure it gets called.  So there are lots of 
   things that can go wrong with a simple operation.</p>

<p>Alternatively, you could create a custom tag called 'startInput' which gives you 
   a place to put the event handler. You can look at the HTML and know what is going 
   on. No ID is required and it does not matter where the Javascript code goes. Here 
   is is the 'startInput' definition ...</p>
   
<pre>
Tags.define({
  tag:'startInput',
  extend:'view',
  htmlTag:'input',
  
  activate: function() {
    this._super();
    this.el.on('click',function() {
      alert('STARTED');
    });
  }
});
</pre>

<h2>Details</h2>
<p>There are a few implied behaviors to be covered.</p>
<ul>
  <li>You can get away without coding the renderText() method if your custom tag renders just like an HTML tag. In this case, you indicate the tag name to use as the attribute 'htmlTag' and rely on the default renderText() method.</li>
  <li>You can invoke an overridden method using the syntax "this._super()". This is part of the Class.js implementation.</li>
  <li>The activate() method of the View Class makes sure this.el is set. It is normally set by the render() method, but if not, and the object has an 'id' attribute, then it is assumed that the 'id' matches the HTML tag and is used to select the HTML tag.</li>
</ul>

<h2>Building a Web Application</h2>

<p>The Tags Framework provides a general purpose mechanism for creating
   and manipulating XML-like structures in Javascript, but Javascript is 
   most often used with HTML. Creating Web applications using HTML is
   the main purpose of the Tags Framework. Some guidelines may be in order
   to say exactly how one might proceed to do that.</p>
   
<p>A Web Application consists of static and dynamic HTML. Static HTML is
   usually what you find in the initial HTML file loaded for any given Web page.
   The Web App has to add event handlers, locate HTML components and
   manipulate those components as events are processed.</p>
   
<p>Dynamic HTML is usually created from scratch and inserted into 
   the DOM on demand. Added DOM elements may later have to be manipulated
   or removed. The challenging part of Web App design is figuring out
   how to make the connections between HTML DOM elements and Javascript
   objects and use these connections to keep track of the state of the
   application.</p>
   
<p>One way to use the Tags Framework is to 
   


<h2>Conclusion</h2>
The Tags Framework is a light-weight, unobtrusive Framework that implements the missing paradigm that connects HTML and Javascript and lets them work together to more easily solve many of the programming tasks required for implementing a Client-Side MVC application.

&nbsp;
</body>
</html>
